items:
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: CSharpExtensions
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions
  type: Class
  source:
    remote: &o0
      path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
      branch: master
      repo: https://github.com/chenkennt/roslyn.git
      key: e7db1294
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 134
  syntax:
    content:
      CSharp: 'public class CSharpExtensions : object'
  inheritance:
  - id: System.Object
    name: object
    isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions
  children:
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimStringLiteral(Microsoft.CodeAnalysis.SyntaxToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimIdentifier(Microsoft.CodeAnalysis.SyntaxToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.VarianceKindFromToken(Microsoft.CodeAnalysis.SyntaxToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,OrderingSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,SelectOrGroupClauseSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,ConstructorInitializerSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,CrefSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,CrefSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ConstructorInitializerSyntax)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,ConstructorInitializerSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,SelectOrGroupClauseSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,ForEachStatementSyntax)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel,AwaitExpressionSyntax)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,ConstructorInitializerSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetIndexerGroup(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConstantValue(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetQueryClauseInfo(Microsoft.CodeAnalysis.SemanticModel,QueryClauseSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,IdentifierNameSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,StatementSyntax,StatementSyntax)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,StatementSyntax)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,StatementSyntax,StatementSyntax)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,StatementSyntax)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,BaseMethodDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,AccessorDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,CrefSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,StatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,EqualsValueClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ConstructorInitializerSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,MemberDeclarationSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,BaseTypeDeclarationSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,EnumMemberDeclarationSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,BaseMethodDeclarationSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,BasePropertyDeclarationSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,EventDeclarationSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,AnonymousObjectMemberDeclaratorSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,AnonymousObjectCreationExpressionSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,AccessorDeclarationSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,VariableDeclaratorSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,LabeledStatementSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,SwitchLabelSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,UsingDirectiveSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,ExternAliasDirectiveSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,TypeParameterSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,ForEachStatementSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,CatchDeclarationSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,QueryClauseSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,JoinIntoClauseSyntax,CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,QueryContinuationSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: Kind(SyntaxToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 145
  syntax:
    content:
      CSharp: public static SyntaxKind Kind(SyntaxToken token)
    parameters:
    - id: token
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
    return:
      id: SyntaxKind
      type:
        id: Microsoft.CodeAnalysis.CSharp.SyntaxKind
        name: SyntaxKind
        href: Microsoft.CodeAnalysis.CSharp.SyntaxKind.yml
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: Kind(SyntaxTrivia)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 151
  syntax:
    content:
      CSharp: public static SyntaxKind Kind(SyntaxTrivia trivia)
    parameters:
    - id: trivia
      type:
        id: Microsoft.CodeAnalysis.SyntaxTrivia
        name: SyntaxTrivia
        href: Microsoft.CodeAnalysis.SyntaxTrivia
    return:
      id: SyntaxKind
      type:
        id: Microsoft.CodeAnalysis.CSharp.SyntaxKind
        name: SyntaxKind
        href: Microsoft.CodeAnalysis.CSharp.SyntaxKind.yml
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: Kind(SyntaxNode)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 157
  syntax:
    content:
      CSharp: public static SyntaxKind Kind(SyntaxNode node)
    parameters:
    - id: node
      type:
        id: Microsoft.CodeAnalysis.SyntaxNode
        name: SyntaxNode
        href: Microsoft.CodeAnalysis.SyntaxNode
    return:
      id: SyntaxKind
      type:
        id: Microsoft.CodeAnalysis.CSharp.SyntaxKind
        name: SyntaxKind
        href: Microsoft.CodeAnalysis.CSharp.SyntaxKind.yml
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: Kind(SyntaxNodeOrToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 163
  syntax:
    content:
      CSharp: public static SyntaxKind Kind(SyntaxNodeOrToken nodeOrToken)
    parameters:
    - id: nodeOrToken
      type:
        id: Microsoft.CodeAnalysis.SyntaxNodeOrToken
        name: SyntaxNodeOrToken
        href: Microsoft.CodeAnalysis.SyntaxNodeOrToken
    return:
      id: SyntaxKind
      type:
        id: Microsoft.CodeAnalysis.CSharp.SyntaxKind
        name: SyntaxKind
        href: Microsoft.CodeAnalysis.CSharp.SyntaxKind.yml
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: IsKeyword(SyntaxToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 169
  syntax:
    content:
      CSharp: public static bool IsKeyword(SyntaxToken token)
    parameters:
    - id: token
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
    return:
      id: Boolean
      type:
        id: System.Boolean
        name: bool
        isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: IsContextualKeyword(SyntaxToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 174
  syntax:
    content:
      CSharp: public static bool IsContextualKeyword(SyntaxToken token)
    parameters:
    - id: token
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
    return:
      id: Boolean
      type:
        id: System.Boolean
        name: bool
        isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: IsReservedKeyword(SyntaxToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 179
  syntax:
    content:
      CSharp: public static bool IsReservedKeyword(SyntaxToken token)
    parameters:
    - id: token
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
    return:
      id: Boolean
      type:
        id: System.Boolean
        name: bool
        isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimStringLiteral(Microsoft.CodeAnalysis.SyntaxToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: IsVerbatimStringLiteral(SyntaxToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimStringLiteral(Microsoft.CodeAnalysis.SyntaxToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 184
  syntax:
    content:
      CSharp: public static bool IsVerbatimStringLiteral(SyntaxToken token)
    parameters:
    - id: token
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
    return:
      id: Boolean
      type:
        id: System.Boolean
        name: bool
        isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimStringLiteral(Microsoft.CodeAnalysis.SyntaxToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimIdentifier(Microsoft.CodeAnalysis.SyntaxToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: IsVerbatimIdentifier(SyntaxToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimIdentifier(Microsoft.CodeAnalysis.SyntaxToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 189
  syntax:
    content:
      CSharp: public static bool IsVerbatimIdentifier(SyntaxToken token)
    parameters:
    - id: token
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
    return:
      id: Boolean
      type:
        id: System.Boolean
        name: bool
        isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimIdentifier(Microsoft.CodeAnalysis.SyntaxToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.VarianceKindFromToken(Microsoft.CodeAnalysis.SyntaxToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: VarianceKindFromToken(SyntaxToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.VarianceKindFromToken(Microsoft.CodeAnalysis.SyntaxToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 194
  syntax:
    content:
      CSharp: public static VarianceKind VarianceKindFromToken(SyntaxToken node)
    parameters:
    - id: node
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
    return:
      id: VarianceKind
      type:
        id: Microsoft.CodeAnalysis.VarianceKind
        name: VarianceKind
        href: Microsoft.CodeAnalysis.VarianceKind
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.VarianceKindFromToken(Microsoft.CodeAnalysis.SyntaxToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: Insert(SyntaxTokenList, int, params SyntaxToken[])
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList, int, params Microsoft.CodeAnalysis.SyntaxToken[])
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 208
  summary: Insert one or more tokens in the list at the specified index.
  syntax:
    content:
      CSharp: public static SyntaxTokenList Insert(SyntaxTokenList list, int index, params SyntaxToken[] items)
    parameters:
    - id: list
      type:
        id: Microsoft.CodeAnalysis.SyntaxTokenList
        name: SyntaxTokenList
        href: Microsoft.CodeAnalysis.SyntaxTokenList
    - id: index
      type:
        id: System.Int32
        name: int
        isExternal: true
    - id: items
      type:
        id: System.Array
        name: SyntaxToken[]
        isExternal: true
    return:
      id: SyntaxTokenList
      type:
        id: Microsoft.CodeAnalysis.SyntaxTokenList
        name: SyntaxTokenList
        href: Microsoft.CodeAnalysis.SyntaxTokenList
      description: A new list with the tokens inserted.
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: ReplaceTrivia(SyntaxToken, IEnumerable<SyntaxTrivia>, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia>)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken, IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia>, Func<Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia>)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 251
  summary: Creates a new token with the specified old trivia replaced with computed new trivia.
  syntax:
    content:
      CSharp: public static SyntaxToken ReplaceTrivia(SyntaxToken token, IEnumerable<SyntaxTrivia> trivia, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia)
    parameters:
    - id: token
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
    - id: trivia
      type:
        id: IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia}
        name: IEnumerable<SyntaxTrivia>
        isExternal: true
      description: The trivia to be replaced; descendants of the root token.
    - id: computeReplacementTrivia
      type:
        id: Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia}
        name: Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia>
        isExternal: true
      description: >-
        A function that computes a replacement trivia for

        the argument trivia. The first argument is the original trivia. The second argument is

        the same trivia rewritten with replaced structure.
    return:
      id: SyntaxToken
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: ReplaceTrivia(SyntaxToken, SyntaxTrivia, SyntaxTrivia)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 264
  summary: >-
    Creates a new token with the specified old trivia replaced with a new trivia. The old trivia may appear in

    the token's leading or trailing trivia.
  syntax:
    content:
      CSharp: public static SyntaxToken ReplaceTrivia(SyntaxToken token, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia)
    parameters:
    - id: token
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
    - id: oldTrivia
      type:
        id: Microsoft.CodeAnalysis.SyntaxTrivia
        name: SyntaxTrivia
        href: Microsoft.CodeAnalysis.SyntaxTrivia
      description: The trivia to be replaced.
    - id: newTrivia
      type:
        id: Microsoft.CodeAnalysis.SyntaxTrivia
        name: SyntaxTrivia
        href: Microsoft.CodeAnalysis.SyntaxTrivia
      description: >-
        The new trivia to use in the new tree in place of the old

        trivia.
    return:
      id: SyntaxToken
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetFirstDirective(SyntaxNode, Func<DirectiveTriviaSyntax, bool>)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode, Func<Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool>)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 327
  summary: Gets the first directive of the tree rooted by this node.
  syntax:
    content:
      CSharp: public static DirectiveTriviaSyntax GetFirstDirective(SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null)
    parameters:
    - id: node
      type:
        id: Microsoft.CodeAnalysis.SyntaxNode
        name: SyntaxNode
        href: Microsoft.CodeAnalysis.SyntaxNode
    - id: predicate
      type:
        id: Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean}
        name: Func<DirectiveTriviaSyntax, bool>
        isExternal: true
    return:
      id: DirectiveTriviaSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
        name: DirectiveTriviaSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax.yml
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetLastDirective(SyntaxNode, Func<DirectiveTriviaSyntax, bool>)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode, Func<Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool>)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 335
  summary: Gets the last directive of the tree rooted by this node.
  syntax:
    content:
      CSharp: public static DirectiveTriviaSyntax GetLastDirective(SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null)
    parameters:
    - id: node
      type:
        id: Microsoft.CodeAnalysis.SyntaxNode
        name: SyntaxNode
        href: Microsoft.CodeAnalysis.SyntaxNode
    - id: predicate
      type:
        id: Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean}
        name: Func<DirectiveTriviaSyntax, bool>
        isExternal: true
    return:
      id: DirectiveTriviaSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
        name: DirectiveTriviaSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax.yml
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetCompilationUnitRoot(SyntaxTree, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 342
  syntax:
    content:
      CSharp: public static CompilationUnitSyntax GetCompilationUnitRoot(SyntaxTree tree, CancellationToken cancellationToken = null)
    parameters:
    - id: tree
      type:
        id: Microsoft.CodeAnalysis.SyntaxTree
        name: SyntaxTree
        href: Microsoft.CodeAnalysis.SyntaxTree
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: CompilationUnitSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax
        name: CompilationUnitSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax.yml
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: ClassifyConversion(Compilation, ITypeSymbol, ITypeSymbol)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation, Microsoft.CodeAnalysis.ITypeSymbol, Microsoft.CodeAnalysis.ITypeSymbol)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 379
  syntax:
    content:
      CSharp: public static Conversion ClassifyConversion(Compilation compilation, ITypeSymbol source, ITypeSymbol destination)
    parameters:
    - id: compilation
      type:
        id: Microsoft.CodeAnalysis.Compilation
        name: Compilation
        href: Microsoft.CodeAnalysis.Compilation
    - id: source
      type:
        id: Microsoft.CodeAnalysis.ITypeSymbol
        name: ITypeSymbol
        href: Microsoft.CodeAnalysis.ITypeSymbol
    - id: destination
      type:
        id: Microsoft.CodeAnalysis.ITypeSymbol
        name: ITypeSymbol
        href: Microsoft.CodeAnalysis.ITypeSymbol
    return:
      id: Conversion
      type:
        id: Microsoft.CodeAnalysis.CSharp.Conversion
        name: Conversion
        href: Microsoft.CodeAnalysis.CSharp.Conversion.yml
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,OrderingSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSymbolInfo(SemanticModel, OrderingSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, OrderingSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 397
  summary: Gets the semantic information for an ordering clause in an orderby query clause.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, OrderingSyntax node, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: node
      type:
        id: OrderingSyntax
        name: OrderingSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: SymbolInfo
      type:
        id: Microsoft.CodeAnalysis.SymbolInfo
        name: SymbolInfo
        href: Microsoft.CodeAnalysis.SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,OrderingSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,SelectOrGroupClauseSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSymbolInfo(SemanticModel, SelectOrGroupClauseSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, SelectOrGroupClauseSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 413
  summary: Gets the semantic information associated with a select or group clause.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: node
      type:
        id: SelectOrGroupClauseSyntax
        name: SelectOrGroupClauseSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: SymbolInfo
      type:
        id: Microsoft.CodeAnalysis.SymbolInfo
        name: SymbolInfo
        href: Microsoft.CodeAnalysis.SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,SelectOrGroupClauseSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSymbolInfo(SemanticModel, ExpressionSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, ExpressionSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 437
  summary: >-
    Returns what symbol(s), if any, the given expression syntax bound to in the program.



    An AliasSymbol will never be returned by this method. What the alias refers to will be

    returned instead. To get information about aliases, call GetAliasInfo.



    If binding the type name C in the expression "new C(...)" the actual constructor bound to

    will be returned (or all constructor if overload resolution failed). This occurs as long as C

    unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple

    types, or C binds to a static class, then type(s) are returned.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: expression
      type:
        id: ExpressionSyntax
        name: ExpressionSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: SymbolInfo
      type:
        id: Microsoft.CodeAnalysis.SymbolInfo
        name: SymbolInfo
        href: Microsoft.CodeAnalysis.SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetCollectionInitializerSymbolInfo(SemanticModel, ExpressionSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, ExpressionSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 454
  summary: >-
    Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax

    within @!:ObjectCreationExpressionSyntax.Initializer-.
  syntax:
    content:
      CSharp: public static SymbolInfo GetCollectionInitializerSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: expression
      type:
        id: ExpressionSyntax
        name: ExpressionSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: SymbolInfo
      type:
        id: Microsoft.CodeAnalysis.SymbolInfo
        name: SymbolInfo
        href: Microsoft.CodeAnalysis.SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,ConstructorInitializerSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSymbolInfo(SemanticModel, ConstructorInitializerSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, ConstructorInitializerSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 470
  summary: Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: constructorInitializer
      type:
        id: ConstructorInitializerSyntax
        name: ConstructorInitializerSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: SymbolInfo
      type:
        id: Microsoft.CodeAnalysis.SymbolInfo
        name: SymbolInfo
        href: Microsoft.CodeAnalysis.SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,ConstructorInitializerSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSymbolInfo(SemanticModel, AttributeSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 486
  summary: Returns what symbol(s), if any, the given attribute syntax bound to in the program.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: attributeSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
        name: AttributeSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax.yml
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: SymbolInfo
      type:
        id: Microsoft.CodeAnalysis.SymbolInfo
        name: SymbolInfo
        href: Microsoft.CodeAnalysis.SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,CrefSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSymbolInfo(SemanticModel, CrefSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, CrefSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 502
  summary: Gets the semantic information associated with a documentation comment cref.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, CrefSyntax crefSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: crefSyntax
      type:
        id: CrefSyntax
        name: CrefSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: SymbolInfo
      type:
        id: Microsoft.CodeAnalysis.SymbolInfo
        name: SymbolInfo
        href: Microsoft.CodeAnalysis.SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,CrefSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSpeculativeSymbolInfo(SemanticModel, int, ExpressionSyntax, SpeculativeBindingOption)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, int, ExpressionSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 520
  summary: >-
    Binds the expression in the context of the specified location and gets symbol information.

    This method is used to get symbol information about an expression that did not actually

    appear in the source code.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSpeculativeSymbolInfo(SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: int
        isExternal: true
    - id: expression
      type:
        id: ExpressionSyntax
        name: ExpressionSyntax
        isExternal: true
    - id: bindingOption
      type:
        id: Microsoft.CodeAnalysis.SpeculativeBindingOption
        name: SpeculativeBindingOption
        href: Microsoft.CodeAnalysis.SpeculativeBindingOption
    return:
      id: SymbolInfo
      type:
        id: Microsoft.CodeAnalysis.SymbolInfo
        name: SymbolInfo
        href: Microsoft.CodeAnalysis.SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,CrefSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSpeculativeSymbolInfo(SemanticModel, int, CrefSyntax, SpeculativeBindingOption)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, int, CrefSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 538
  summary: >-
    Binds the CrefSyntax expression in the context of the specified location and gets symbol information.

    This method is used to get symbol information about an expression that did not actually

    appear in the source code.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSpeculativeSymbolInfo(SemanticModel semanticModel, int position, CrefSyntax expression, SpeculativeBindingOption bindingOption)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: int
        isExternal: true
    - id: expression
      type:
        id: CrefSyntax
        name: CrefSyntax
        isExternal: true
    - id: bindingOption
      type:
        id: Microsoft.CodeAnalysis.SpeculativeBindingOption
        name: SpeculativeBindingOption
        href: Microsoft.CodeAnalysis.SpeculativeBindingOption
    return:
      id: SymbolInfo
      type:
        id: Microsoft.CodeAnalysis.SymbolInfo
        name: SymbolInfo
        href: Microsoft.CodeAnalysis.SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,CrefSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSpeculativeSymbolInfo(SemanticModel, int, AttributeSyntax)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 556
  summary: >-
    Bind the attribute in the context of the specified location and get semantic information

    such as type, symbols and diagnostics. This method is used to get semantic information about an attribute

    that did not actually appear in the source code.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSpeculativeSymbolInfo(SemanticModel semanticModel, int position, AttributeSyntax attribute)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: int
        isExternal: true
    - id: attribute
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
        name: AttributeSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax.yml
    return:
      id: SymbolInfo
      type:
        id: Microsoft.CodeAnalysis.SymbolInfo
        name: SymbolInfo
        href: Microsoft.CodeAnalysis.SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ConstructorInitializerSyntax)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSpeculativeSymbolInfo(SemanticModel, int, ConstructorInitializerSyntax)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, int, ConstructorInitializerSyntax)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 576
  summary: >-
    Bind the constructor initializer in the context of the specified location and get semantic information

    such as type, symbols and diagnostics. This method is used to get semantic information about a constructor

    initializer that did not actually appear in the source code.



    NOTE: This will only work in locations where there is already a constructor initializer.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSpeculativeSymbolInfo(SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: int
        isExternal: true
    - id: constructorInitializer
      type:
        id: ConstructorInitializerSyntax
        name: ConstructorInitializerSyntax
        isExternal: true
    return:
      id: SymbolInfo
      type:
        id: Microsoft.CodeAnalysis.SymbolInfo
        name: SymbolInfo
        href: Microsoft.CodeAnalysis.SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ConstructorInitializerSyntax)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,ConstructorInitializerSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetTypeInfo(SemanticModel, ConstructorInitializerSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel, ConstructorInitializerSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 592
  summary: Gets type information about a constructor initializer.
  syntax:
    content:
      CSharp: public static TypeInfo GetTypeInfo(SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: constructorInitializer
      type:
        id: ConstructorInitializerSyntax
        name: ConstructorInitializerSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: TypeInfo
      type:
        id: Microsoft.CodeAnalysis.TypeInfo
        name: TypeInfo
        href: Microsoft.CodeAnalysis.TypeInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,ConstructorInitializerSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,SelectOrGroupClauseSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetTypeInfo(SemanticModel, SelectOrGroupClauseSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel, SelectOrGroupClauseSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 606
  syntax:
    content:
      CSharp: public static TypeInfo GetTypeInfo(SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: node
      type:
        id: SelectOrGroupClauseSyntax
        name: SelectOrGroupClauseSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: TypeInfo
      type:
        id: Microsoft.CodeAnalysis.TypeInfo
        name: TypeInfo
        href: Microsoft.CodeAnalysis.TypeInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,SelectOrGroupClauseSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetTypeInfo(SemanticModel, ExpressionSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel, ExpressionSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 622
  summary: Gets type information about an expression.
  syntax:
    content:
      CSharp: public static TypeInfo GetTypeInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: expression
      type:
        id: ExpressionSyntax
        name: ExpressionSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: TypeInfo
      type:
        id: Microsoft.CodeAnalysis.TypeInfo
        name: TypeInfo
        href: Microsoft.CodeAnalysis.TypeInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetTypeInfo(SemanticModel, AttributeSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 638
  summary: Gets type information about an attribute.
  syntax:
    content:
      CSharp: public static TypeInfo GetTypeInfo(SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: attributeSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
        name: AttributeSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax.yml
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: TypeInfo
      type:
        id: Microsoft.CodeAnalysis.TypeInfo
        name: TypeInfo
        href: Microsoft.CodeAnalysis.TypeInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSpeculativeTypeInfo(SemanticModel, int, ExpressionSyntax, SpeculativeBindingOption)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel, int, ExpressionSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 656
  summary: >-
    Binds the expression in the context of the specified location and gets type information.

    This method is used to get type information about an expression that did not actually

    appear in the source code.
  syntax:
    content:
      CSharp: public static TypeInfo GetSpeculativeTypeInfo(SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: int
        isExternal: true
    - id: expression
      type:
        id: ExpressionSyntax
        name: ExpressionSyntax
        isExternal: true
    - id: bindingOption
      type:
        id: Microsoft.CodeAnalysis.SpeculativeBindingOption
        name: SpeculativeBindingOption
        href: Microsoft.CodeAnalysis.SpeculativeBindingOption
    return:
      id: TypeInfo
      type:
        id: Microsoft.CodeAnalysis.TypeInfo
        name: TypeInfo
        href: Microsoft.CodeAnalysis.TypeInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetConversion(SemanticModel, SyntaxNode, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.SyntaxNode, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 669
  syntax:
    content:
      CSharp: public static Conversion GetConversion(SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: expression
      type:
        id: Microsoft.CodeAnalysis.SyntaxNode
        name: SyntaxNode
        href: Microsoft.CodeAnalysis.SyntaxNode
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: Conversion
      type:
        id: Microsoft.CodeAnalysis.CSharp.Conversion
        name: Conversion
        href: Microsoft.CodeAnalysis.CSharp.Conversion.yml
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSpeculativeConversion(SemanticModel, int, ExpressionSyntax, SpeculativeBindingOption)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeConversion(Microsoft.CodeAnalysis.SemanticModel, int, ExpressionSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 682
  syntax:
    content:
      CSharp: public static Conversion GetSpeculativeConversion(SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: int
        isExternal: true
    - id: expression
      type:
        id: ExpressionSyntax
        name: ExpressionSyntax
        isExternal: true
    - id: bindingOption
      type:
        id: Microsoft.CodeAnalysis.SpeculativeBindingOption
        name: SpeculativeBindingOption
        href: Microsoft.CodeAnalysis.SpeculativeBindingOption
    return:
      id: Conversion
      type:
        id: Microsoft.CodeAnalysis.CSharp.Conversion
        name: Conversion
        href: Microsoft.CodeAnalysis.CSharp.Conversion.yml
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,ForEachStatementSyntax)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetForEachStatementInfo(SemanticModel, ForEachStatementSyntax)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel, ForEachStatementSyntax)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 695
  syntax:
    content:
      CSharp: public static ForEachStatementInfo GetForEachStatementInfo(SemanticModel semanticModel, ForEachStatementSyntax forEachStatement)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: forEachStatement
      type:
        id: ForEachStatementSyntax
        name: ForEachStatementSyntax
        isExternal: true
    return:
      id: ForEachStatementInfo
      type:
        id: Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo
        name: ForEachStatementInfo
        href: Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.yml
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,ForEachStatementSyntax)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel,AwaitExpressionSyntax)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetAwaitExpressionInfo(SemanticModel, AwaitExpressionSyntax)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel, AwaitExpressionSyntax)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 708
  syntax:
    content:
      CSharp: public static AwaitExpressionInfo GetAwaitExpressionInfo(SemanticModel semanticModel, AwaitExpressionSyntax awaitExpression)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: awaitExpression
      type:
        id: AwaitExpressionSyntax
        name: AwaitExpressionSyntax
        isExternal: true
    return:
      id: AwaitExpressionInfo
      type:
        id: Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo
        name: AwaitExpressionInfo
        href: Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo.yml
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel,AwaitExpressionSyntax)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetMemberGroup(SemanticModel, ExpressionSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel, ExpressionSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 721
  syntax:
    content:
      CSharp: public static ImmutableArray<ISymbol> GetMemberGroup(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: expression
      type:
        id: ExpressionSyntax
        name: ExpressionSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: ImmutableArray
      type:
        id: ImmutableArray{Microsoft.CodeAnalysis.ISymbol}
        name: ImmutableArray<ISymbol>
        isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetMemberGroup(SemanticModel, AttributeSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 734
  syntax:
    content:
      CSharp: public static ImmutableArray<ISymbol> GetMemberGroup(SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: attribute
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
        name: AttributeSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax.yml
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: ImmutableArray
      type:
        id: ImmutableArray{Microsoft.CodeAnalysis.ISymbol}
        name: ImmutableArray<ISymbol>
        isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,ConstructorInitializerSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetMemberGroup(SemanticModel, ConstructorInitializerSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel, ConstructorInitializerSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 747
  syntax:
    content:
      CSharp: public static ImmutableArray<ISymbol> GetMemberGroup(SemanticModel semanticModel, ConstructorInitializerSyntax initializer, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: initializer
      type:
        id: ConstructorInitializerSyntax
        name: ConstructorInitializerSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: ImmutableArray
      type:
        id: ImmutableArray{Microsoft.CodeAnalysis.ISymbol}
        name: ImmutableArray<ISymbol>
        isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,ConstructorInitializerSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetIndexerGroup(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetIndexerGroup(SemanticModel, ExpressionSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetIndexerGroup(Microsoft.CodeAnalysis.SemanticModel, ExpressionSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 763
  summary: Returns the list of accessible, non-hidden indexers that could be invoked with the given expression as receiver.
  syntax:
    content:
      CSharp: public static ImmutableArray<IPropertySymbol> GetIndexerGroup(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: expression
      type:
        id: ExpressionSyntax
        name: ExpressionSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: ImmutableArray
      type:
        id: ImmutableArray{Microsoft.CodeAnalysis.IPropertySymbol}
        name: ImmutableArray<IPropertySymbol>
        isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetIndexerGroup(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConstantValue(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetConstantValue(SemanticModel, ExpressionSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConstantValue(Microsoft.CodeAnalysis.SemanticModel, ExpressionSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 776
  syntax:
    content:
      CSharp: public static Optional<object> GetConstantValue(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: expression
      type:
        id: ExpressionSyntax
        name: ExpressionSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: Optional
      type:
        id: Microsoft.CodeAnalysis.Optional{System.Object}
        name: Optional<object>
        href: Microsoft.CodeAnalysis.Optional{System.Object}
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConstantValue(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetQueryClauseInfo(Microsoft.CodeAnalysis.SemanticModel,QueryClauseSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetQueryClauseInfo(SemanticModel, QueryClauseSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetQueryClauseInfo(Microsoft.CodeAnalysis.SemanticModel, QueryClauseSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 792
  summary: Gets the semantic information associated with a query clause.
  syntax:
    content:
      CSharp: public static QueryClauseInfo GetQueryClauseInfo(SemanticModel semanticModel, QueryClauseSyntax node, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: node
      type:
        id: QueryClauseSyntax
        name: QueryClauseSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: QueryClauseInfo
      type:
        id: Microsoft.CodeAnalysis.CSharp.QueryClauseInfo
        name: QueryClauseInfo
        href: Microsoft.CodeAnalysis.CSharp.QueryClauseInfo.yml
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetQueryClauseInfo(Microsoft.CodeAnalysis.SemanticModel,QueryClauseSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,IdentifierNameSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetAliasInfo(SemanticModel, IdentifierNameSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel, IdentifierNameSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 809
  summary: >-
    If  resolves to an alias name, return the AliasSymbol corresponding

    to A. Otherwise return null.
  syntax:
    content:
      CSharp: public static IAliasSymbol GetAliasInfo(SemanticModel semanticModel, IdentifierNameSyntax nameSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: nameSyntax
      type:
        id: IdentifierNameSyntax
        name: IdentifierNameSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: IAliasSymbol
      type:
        id: Microsoft.CodeAnalysis.IAliasSymbol
        name: IAliasSymbol
        href: Microsoft.CodeAnalysis.IAliasSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,IdentifierNameSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSpeculativeAliasInfo(SemanticModel, int, IdentifierNameSyntax, SpeculativeBindingOption)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel, int, IdentifierNameSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 826
  summary: >-
    Binds the name in the context of the specified location and sees if it resolves to an

    alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
  syntax:
    content:
      CSharp: public static IAliasSymbol GetSpeculativeAliasInfo(SemanticModel semanticModel, int position, IdentifierNameSyntax nameSyntax, SpeculativeBindingOption bindingOption)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: int
        isExternal: true
    - id: nameSyntax
      type:
        id: IdentifierNameSyntax
        name: IdentifierNameSyntax
        isExternal: true
    - id: bindingOption
      type:
        id: Microsoft.CodeAnalysis.SpeculativeBindingOption
        name: SpeculativeBindingOption
        href: Microsoft.CodeAnalysis.SpeculativeBindingOption
    return:
      id: IAliasSymbol
      type:
        id: Microsoft.CodeAnalysis.IAliasSymbol
        name: IAliasSymbol
        href: Microsoft.CodeAnalysis.IAliasSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,StatementSyntax,StatementSyntax)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: AnalyzeControlFlow(SemanticModel, StatementSyntax, StatementSyntax)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel, StatementSyntax, StatementSyntax)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 842
  summary: Analyze control-flow within a part of a method body.
  syntax:
    content:
      CSharp: public static ControlFlowAnalysis AnalyzeControlFlow(SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: firstStatement
      type:
        id: StatementSyntax
        name: StatementSyntax
        isExternal: true
    - id: lastStatement
      type:
        id: StatementSyntax
        name: StatementSyntax
        isExternal: true
    return:
      id: ControlFlowAnalysis
      type:
        id: Microsoft.CodeAnalysis.ControlFlowAnalysis
        name: ControlFlowAnalysis
        href: Microsoft.CodeAnalysis.ControlFlowAnalysis
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,StatementSyntax,StatementSyntax)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,StatementSyntax)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: AnalyzeControlFlow(SemanticModel, StatementSyntax)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel, StatementSyntax)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 858
  summary: Analyze control-flow within a part of a method body.
  syntax:
    content:
      CSharp: public static ControlFlowAnalysis AnalyzeControlFlow(SemanticModel semanticModel, StatementSyntax statement)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: statement
      type:
        id: StatementSyntax
        name: StatementSyntax
        isExternal: true
    return:
      id: ControlFlowAnalysis
      type:
        id: Microsoft.CodeAnalysis.ControlFlowAnalysis
        name: ControlFlowAnalysis
        href: Microsoft.CodeAnalysis.ControlFlowAnalysis
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,StatementSyntax)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: AnalyzeDataFlow(SemanticModel, ExpressionSyntax)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel, ExpressionSyntax)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 874
  summary: Analyze data-flow within an expression.
  syntax:
    content:
      CSharp: public static DataFlowAnalysis AnalyzeDataFlow(SemanticModel semanticModel, ExpressionSyntax expression)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: expression
      type:
        id: ExpressionSyntax
        name: ExpressionSyntax
        isExternal: true
    return:
      id: DataFlowAnalysis
      type:
        id: Microsoft.CodeAnalysis.DataFlowAnalysis
        name: DataFlowAnalysis
        href: Microsoft.CodeAnalysis.DataFlowAnalysis
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,StatementSyntax,StatementSyntax)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: AnalyzeDataFlow(SemanticModel, StatementSyntax, StatementSyntax)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel, StatementSyntax, StatementSyntax)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 890
  summary: Analyze data-flow within a part of a method body.
  syntax:
    content:
      CSharp: public static DataFlowAnalysis AnalyzeDataFlow(SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: firstStatement
      type:
        id: StatementSyntax
        name: StatementSyntax
        isExternal: true
    - id: lastStatement
      type:
        id: StatementSyntax
        name: StatementSyntax
        isExternal: true
    return:
      id: DataFlowAnalysis
      type:
        id: Microsoft.CodeAnalysis.DataFlowAnalysis
        name: DataFlowAnalysis
        href: Microsoft.CodeAnalysis.DataFlowAnalysis
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,StatementSyntax,StatementSyntax)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,StatementSyntax)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: AnalyzeDataFlow(SemanticModel, StatementSyntax)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel, StatementSyntax)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 906
  summary: Analyze data-flow within a part of a method body.
  syntax:
    content:
      CSharp: public static DataFlowAnalysis AnalyzeDataFlow(SemanticModel semanticModel, StatementSyntax statement)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: statement
      type:
        id: StatementSyntax
        name: StatementSyntax
        isExternal: true
    return:
      id: DataFlowAnalysis
      type:
        id: Microsoft.CodeAnalysis.DataFlowAnalysis
        name: DataFlowAnalysis
        href: Microsoft.CodeAnalysis.DataFlowAnalysis
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,StatementSyntax)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,BaseMethodDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: TryGetSpeculativeSemanticModelForMethodBody(SemanticModel, int, BaseMethodDeclarationSyntax, out SemanticModel)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel, int, BaseMethodDeclarationSyntax, out Microsoft.CodeAnalysis.SemanticModel)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 924
  summary: >-
    Get a SemanticModel object that is associated with a method body that did not appear in this source code.

    Given  must lie within an existing method body of the Root syntax node for this SemanticModel.

    Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
  syntax:
    content:
      CSharp: public static bool TryGetSpeculativeSemanticModelForMethodBody(SemanticModel semanticModel, int position, BaseMethodDeclarationSyntax method, out SemanticModel speculativeModel)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: int
        isExternal: true
    - id: method
      type:
        id: BaseMethodDeclarationSyntax
        name: BaseMethodDeclarationSyntax
        isExternal: true
    - id: speculativeModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    return:
      id: Boolean
      type:
        id: System.Boolean
        name: bool
        isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,BaseMethodDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,AccessorDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: TryGetSpeculativeSemanticModelForMethodBody(SemanticModel, int, AccessorDeclarationSyntax, out SemanticModel)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel, int, AccessorDeclarationSyntax, out Microsoft.CodeAnalysis.SemanticModel)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 943
  summary: >-
    Get a SemanticModel object that is associated with a method body that did not appear in this source code.

    Given  must lie within an existing method body of the Root syntax node for this SemanticModel.

    Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
  syntax:
    content:
      CSharp: public static bool TryGetSpeculativeSemanticModelForMethodBody(SemanticModel semanticModel, int position, AccessorDeclarationSyntax accessor, out SemanticModel speculativeModel)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: int
        isExternal: true
    - id: accessor
      type:
        id: AccessorDeclarationSyntax
        name: AccessorDeclarationSyntax
        isExternal: true
    - id: speculativeModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    return:
      id: Boolean
      type:
        id: System.Boolean
        name: bool
        isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,AccessorDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: TryGetSpeculativeSemanticModel(SemanticModel, int, TypeSyntax, out SemanticModel, SpeculativeBindingOption)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax, out Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.SpeculativeBindingOption)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 962
  summary: >-
    Get a SemanticModel object that is associated with a type syntax node that did not appear in

    this source code. This can be used to get detailed semantic information about sub-parts

    of a type syntax that did not appear in source code.
  syntax:
    content:
      CSharp: public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, TypeSyntax type, out SemanticModel speculativeModel, SpeculativeBindingOption bindingOption = 0)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: int
        isExternal: true
    - id: type
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
        name: TypeSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax.yml
    - id: speculativeModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: bindingOption
      type:
        id: Microsoft.CodeAnalysis.SpeculativeBindingOption
        name: SpeculativeBindingOption
        href: Microsoft.CodeAnalysis.SpeculativeBindingOption
    return:
      id: Boolean
      type:
        id: System.Boolean
        name: bool
        isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,CrefSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: TryGetSpeculativeSemanticModel(SemanticModel, int, CrefSyntax, out SemanticModel)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel, int, CrefSyntax, out Microsoft.CodeAnalysis.SemanticModel)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 981
  summary: >-
    Get a SemanticModel object that is associated with a cref syntax node that did not appear in

    this source code. This can be used to get detailed semantic information about sub-parts

    of a cref syntax that did not appear in source code.
  syntax:
    content:
      CSharp: public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, CrefSyntax crefSyntax, out SemanticModel speculativeModel)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: int
        isExternal: true
    - id: crefSyntax
      type:
        id: CrefSyntax
        name: CrefSyntax
        isExternal: true
    - id: speculativeModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    return:
      id: Boolean
      type:
        id: System.Boolean
        name: bool
        isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,CrefSyntax,Microsoft.CodeAnalysis.SemanticModel@)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,StatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: TryGetSpeculativeSemanticModel(SemanticModel, int, StatementSyntax, out SemanticModel)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel, int, StatementSyntax, out Microsoft.CodeAnalysis.SemanticModel)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1000
  summary: >-
    Get a SemanticModel object that is associated with a statement that did not appear in

    this source code. This can be used to get detailed semantic information about sub-parts

    of a statement that did not appear in source code.
  syntax:
    content:
      CSharp: public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, StatementSyntax statement, out SemanticModel speculativeModel)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: int
        isExternal: true
    - id: statement
      type:
        id: StatementSyntax
        name: StatementSyntax
        isExternal: true
    - id: speculativeModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    return:
      id: Boolean
      type:
        id: System.Boolean
        name: bool
        isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,StatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,EqualsValueClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: TryGetSpeculativeSemanticModel(SemanticModel, int, EqualsValueClauseSyntax, out SemanticModel)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel, int, EqualsValueClauseSyntax, out Microsoft.CodeAnalysis.SemanticModel)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1019
  summary: >-
    Get a SemanticModel object that is associated with an initializer that did not appear in

    this source code. This can be used to get detailed semantic information about sub-parts

    of a field initializer or default parameter value that did not appear in source code.
  syntax:
    content:
      CSharp: public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, EqualsValueClauseSyntax initializer, out SemanticModel speculativeModel)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: int
        isExternal: true
    - id: initializer
      type:
        id: EqualsValueClauseSyntax
        name: EqualsValueClauseSyntax
        isExternal: true
    - id: speculativeModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    return:
      id: Boolean
      type:
        id: System.Boolean
        name: bool
        isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,EqualsValueClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: TryGetSpeculativeSemanticModel(SemanticModel, int, ArrowExpressionClauseSyntax, out SemanticModel)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel, int, ArrowExpressionClauseSyntax, out Microsoft.CodeAnalysis.SemanticModel)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1038
  summary: >-
    Get a SemanticModel object that is associated with an expression body that did not appear in

    this source code. This can be used to get detailed semantic information about sub-parts

    of an expression body that did not appear in source code.
  syntax:
    content:
      CSharp: public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, ArrowExpressionClauseSyntax expressionBody, out SemanticModel speculativeModel)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: int
        isExternal: true
    - id: expressionBody
      type:
        id: ArrowExpressionClauseSyntax
        name: ArrowExpressionClauseSyntax
        isExternal: true
    - id: speculativeModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    return:
      id: Boolean
      type:
        id: System.Boolean
        name: bool
        isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ConstructorInitializerSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: TryGetSpeculativeSemanticModel(SemanticModel, int, ConstructorInitializerSyntax, out SemanticModel)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel, int, ConstructorInitializerSyntax, out Microsoft.CodeAnalysis.SemanticModel)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1059
  summary: >-
    Get a SemanticModel object that is associated with a constructor initializer that did not appear in

    this source code. This can be used to get detailed semantic information about sub-parts

    of a constructor initializer that did not appear in source code.



    NOTE: This will only work in locations where there is already a constructor initializer.
  syntax:
    content:
      CSharp: public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer, out SemanticModel speculativeModel)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: int
        isExternal: true
    - id: constructorInitializer
      type:
        id: ConstructorInitializerSyntax
        name: ConstructorInitializerSyntax
        isExternal: true
    - id: speculativeModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    return:
      id: Boolean
      type:
        id: System.Boolean
        name: bool
        isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ConstructorInitializerSyntax,Microsoft.CodeAnalysis.SemanticModel@)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: TryGetSpeculativeSemanticModel(SemanticModel, int, AttributeSyntax, out SemanticModel)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax, out Microsoft.CodeAnalysis.SemanticModel)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1078
  summary: >-
    Get a SemanticModel object that is associated with an attribute that did not appear in

    this source code. This can be used to get detailed semantic information about sub-parts

    of an attribute that did not appear in source code.
  syntax:
    content:
      CSharp: public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, AttributeSyntax attribute, out SemanticModel speculativeModel)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: int
        isExternal: true
    - id: attribute
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
        name: AttributeSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax.yml
    - id: speculativeModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    return:
      id: Boolean
      type:
        id: System.Boolean
        name: bool
        isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: ClassifyConversion(SemanticModel, ExpressionSyntax, ITypeSymbol, bool)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel, ExpressionSyntax, Microsoft.CodeAnalysis.ITypeSymbol, bool)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1097
  summary: >-
    Determines what type of conversion, if any, would be used if a given expression was

    converted to a given type.  If isExplicitInSource is true, the conversion produced is

    that which would be used if the conversion were done for a cast expression.
  syntax:
    content:
      CSharp: public static Conversion ClassifyConversion(SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: expression
      type:
        id: ExpressionSyntax
        name: ExpressionSyntax
        isExternal: true
    - id: destination
      type:
        id: Microsoft.CodeAnalysis.ITypeSymbol
        name: ITypeSymbol
        href: Microsoft.CodeAnalysis.ITypeSymbol
    - id: isExplicitInSource
      type:
        id: System.Boolean
        name: bool
        isExternal: true
    return:
      id: Conversion
      type:
        id: Microsoft.CodeAnalysis.CSharp.Conversion
        name: Conversion
        href: Microsoft.CodeAnalysis.CSharp.Conversion.yml
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: ClassifyConversion(SemanticModel, int, ExpressionSyntax, ITypeSymbol, bool)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel, int, ExpressionSyntax, Microsoft.CodeAnalysis.ITypeSymbol, bool)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1115
  summary: >-
    Determines what type of conversion, if any, would be used if a given expression was

    converted to a given type.  If isExplicitInSource is true, the conversion produced is

    that which would be used if the conversion were done for a cast expression.
  syntax:
    content:
      CSharp: public static Conversion ClassifyConversion(SemanticModel semanticModel, int position, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: int
        isExternal: true
    - id: expression
      type:
        id: ExpressionSyntax
        name: ExpressionSyntax
        isExternal: true
    - id: destination
      type:
        id: Microsoft.CodeAnalysis.ITypeSymbol
        name: ITypeSymbol
        href: Microsoft.CodeAnalysis.ITypeSymbol
    - id: isExplicitInSource
      type:
        id: System.Boolean
        name: bool
        isExternal: true
    return:
      id: Conversion
      type:
        id: Microsoft.CodeAnalysis.CSharp.Conversion
        name: Conversion
        href: Microsoft.CodeAnalysis.CSharp.Conversion.yml
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,MemberDeclarationSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, MemberDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, MemberDeclarationSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1131
  summary: Given a member declaration syntax, get the corresponding symbol.
  syntax:
    content:
      CSharp: public static ISymbol GetDeclaredSymbol(SemanticModel semanticModel, MemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: MemberDeclarationSyntax
        name: MemberDeclarationSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: ISymbol
      type:
        id: Microsoft.CodeAnalysis.ISymbol
        name: ISymbol
        href: Microsoft.CodeAnalysis.ISymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,MemberDeclarationSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, NamespaceDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1148
  summary: >-
    Given a namespace declaration syntax node, get the corresponding namespace symbol for

    the declaration assembly.
  syntax:
    content:
      CSharp: public static INamespaceSymbol GetDeclaredSymbol(SemanticModel semanticModel, NamespaceDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
        name: NamespaceDeclarationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax.yml
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: INamespaceSymbol
      type:
        id: Microsoft.CodeAnalysis.INamespaceSymbol
        name: INamespaceSymbol
        href: Microsoft.CodeAnalysis.INamespaceSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,BaseTypeDeclarationSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, BaseTypeDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, BaseTypeDeclarationSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1164
  summary: Given a type declaration, get the corresponding type symbol.
  syntax:
    content:
      CSharp: public static INamedTypeSymbol GetDeclaredSymbol(SemanticModel semanticModel, BaseTypeDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: BaseTypeDeclarationSyntax
        name: BaseTypeDeclarationSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: INamedTypeSymbol
      type:
        id: Microsoft.CodeAnalysis.INamedTypeSymbol
        name: INamedTypeSymbol
        href: Microsoft.CodeAnalysis.INamedTypeSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,BaseTypeDeclarationSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, DelegateDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1180
  summary: Given a delegate declaration, get the corresponding type symbol.
  syntax:
    content:
      CSharp: public static INamedTypeSymbol GetDeclaredSymbol(SemanticModel semanticModel, DelegateDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax
        name: DelegateDeclarationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax.yml
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: INamedTypeSymbol
      type:
        id: Microsoft.CodeAnalysis.INamedTypeSymbol
        name: INamedTypeSymbol
        href: Microsoft.CodeAnalysis.INamedTypeSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,EnumMemberDeclarationSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, EnumMemberDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, EnumMemberDeclarationSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1196
  summary: Given a enum member declaration, get the corresponding field symbol.
  syntax:
    content:
      CSharp: public static IFieldSymbol GetDeclaredSymbol(SemanticModel semanticModel, EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: EnumMemberDeclarationSyntax
        name: EnumMemberDeclarationSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: IFieldSymbol
      type:
        id: Microsoft.CodeAnalysis.IFieldSymbol
        name: IFieldSymbol
        href: Microsoft.CodeAnalysis.IFieldSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,EnumMemberDeclarationSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,BaseMethodDeclarationSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, BaseMethodDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, BaseMethodDeclarationSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1212
  summary: Given a base method declaration syntax, get the corresponding method symbol.
  syntax:
    content:
      CSharp: public static IMethodSymbol GetDeclaredSymbol(SemanticModel semanticModel, BaseMethodDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: BaseMethodDeclarationSyntax
        name: BaseMethodDeclarationSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: IMethodSymbol
      type:
        id: Microsoft.CodeAnalysis.IMethodSymbol
        name: IMethodSymbol
        href: Microsoft.CodeAnalysis.IMethodSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,BaseMethodDeclarationSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,BasePropertyDeclarationSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, BasePropertyDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, BasePropertyDeclarationSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1228
  summary: Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.
  syntax:
    content:
      CSharp: public static ISymbol GetDeclaredSymbol(SemanticModel semanticModel, BasePropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: BasePropertyDeclarationSyntax
        name: BasePropertyDeclarationSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: ISymbol
      type:
        id: Microsoft.CodeAnalysis.ISymbol
        name: ISymbol
        href: Microsoft.CodeAnalysis.ISymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,BasePropertyDeclarationSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, PropertyDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1244
  summary: Given a syntax node that declares a property, get the corresponding declared symbol.
  syntax:
    content:
      CSharp: public static IPropertySymbol GetDeclaredSymbol(SemanticModel semanticModel, PropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
        name: PropertyDeclarationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax.yml
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: IPropertySymbol
      type:
        id: Microsoft.CodeAnalysis.IPropertySymbol
        name: IPropertySymbol
        href: Microsoft.CodeAnalysis.IPropertySymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, IndexerDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1260
  summary: Given a syntax node that declares an indexer, get the corresponding declared symbol.
  syntax:
    content:
      CSharp: public static IPropertySymbol GetDeclaredSymbol(SemanticModel semanticModel, IndexerDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax
        name: IndexerDeclarationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax.yml
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: IPropertySymbol
      type:
        id: Microsoft.CodeAnalysis.IPropertySymbol
        name: IPropertySymbol
        href: Microsoft.CodeAnalysis.IPropertySymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,EventDeclarationSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, EventDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, EventDeclarationSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1276
  summary: Given a syntax node that declares a (custom) event, get the corresponding event symbol.
  syntax:
    content:
      CSharp: public static IEventSymbol GetDeclaredSymbol(SemanticModel semanticModel, EventDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: EventDeclarationSyntax
        name: EventDeclarationSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: IEventSymbol
      type:
        id: Microsoft.CodeAnalysis.IEventSymbol
        name: IEventSymbol
        href: Microsoft.CodeAnalysis.IEventSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,EventDeclarationSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,AnonymousObjectMemberDeclaratorSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, AnonymousObjectMemberDeclaratorSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, AnonymousObjectMemberDeclaratorSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1292
  summary: Given a syntax node of anonymous object creation initializer, get the anonymous object property symbol.
  syntax:
    content:
      CSharp: public static IPropertySymbol GetDeclaredSymbol(SemanticModel semanticModel, AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declaratorSyntax
      type:
        id: AnonymousObjectMemberDeclaratorSyntax
        name: AnonymousObjectMemberDeclaratorSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: IPropertySymbol
      type:
        id: Microsoft.CodeAnalysis.IPropertySymbol
        name: IPropertySymbol
        href: Microsoft.CodeAnalysis.IPropertySymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,AnonymousObjectMemberDeclaratorSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,AnonymousObjectCreationExpressionSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, AnonymousObjectCreationExpressionSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, AnonymousObjectCreationExpressionSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1308
  summary: Given a syntax node of anonymous object creation expression, get the anonymous object type symbol.
  syntax:
    content:
      CSharp: public static INamedTypeSymbol GetDeclaredSymbol(SemanticModel semanticModel, AnonymousObjectCreationExpressionSyntax declaratorSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declaratorSyntax
      type:
        id: AnonymousObjectCreationExpressionSyntax
        name: AnonymousObjectCreationExpressionSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: INamedTypeSymbol
      type:
        id: Microsoft.CodeAnalysis.INamedTypeSymbol
        name: INamedTypeSymbol
        href: Microsoft.CodeAnalysis.INamedTypeSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,AnonymousObjectCreationExpressionSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,AccessorDeclarationSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, AccessorDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, AccessorDeclarationSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1324
  summary: Given a syntax node that declares a property or member accessor, get the corresponding symbol.
  syntax:
    content:
      CSharp: public static IMethodSymbol GetDeclaredSymbol(SemanticModel semanticModel, AccessorDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: AccessorDeclarationSyntax
        name: AccessorDeclarationSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: IMethodSymbol
      type:
        id: Microsoft.CodeAnalysis.IMethodSymbol
        name: IMethodSymbol
        href: Microsoft.CodeAnalysis.IMethodSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,AccessorDeclarationSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,VariableDeclaratorSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, VariableDeclaratorSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, VariableDeclaratorSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1340
  summary: Given a variable declarator syntax, get the corresponding symbol.
  syntax:
    content:
      CSharp: public static ISymbol GetDeclaredSymbol(SemanticModel semanticModel, VariableDeclaratorSyntax declarationSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: VariableDeclaratorSyntax
        name: VariableDeclaratorSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: ISymbol
      type:
        id: Microsoft.CodeAnalysis.ISymbol
        name: ISymbol
        href: Microsoft.CodeAnalysis.ISymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,VariableDeclaratorSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,LabeledStatementSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, LabeledStatementSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, LabeledStatementSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1356
  summary: Given a labeled statement syntax, get the corresponding label symbol.
  syntax:
    content:
      CSharp: public static ILabelSymbol GetDeclaredSymbol(SemanticModel semanticModel, LabeledStatementSyntax declarationSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: LabeledStatementSyntax
        name: LabeledStatementSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: ILabelSymbol
      type:
        id: Microsoft.CodeAnalysis.ILabelSymbol
        name: ILabelSymbol
        href: Microsoft.CodeAnalysis.ILabelSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,LabeledStatementSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,SwitchLabelSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, SwitchLabelSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, SwitchLabelSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1372
  summary: Given a switch label syntax, get the corresponding label symbol.
  syntax:
    content:
      CSharp: public static ILabelSymbol GetDeclaredSymbol(SemanticModel semanticModel, SwitchLabelSyntax declarationSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: SwitchLabelSyntax
        name: SwitchLabelSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: ILabelSymbol
      type:
        id: Microsoft.CodeAnalysis.ILabelSymbol
        name: ILabelSymbol
        href: Microsoft.CodeAnalysis.ILabelSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,SwitchLabelSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,UsingDirectiveSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, UsingDirectiveSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, UsingDirectiveSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1388
  summary: Given a using declaration get the corresponding symbol for the using alias that was introduced.
  syntax:
    content:
      CSharp: public static IAliasSymbol GetDeclaredSymbol(SemanticModel semanticModel, UsingDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: UsingDirectiveSyntax
        name: UsingDirectiveSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: IAliasSymbol
      type:
        id: Microsoft.CodeAnalysis.IAliasSymbol
        name: IAliasSymbol
        href: Microsoft.CodeAnalysis.IAliasSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,UsingDirectiveSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,ExternAliasDirectiveSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, ExternAliasDirectiveSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, ExternAliasDirectiveSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1404
  summary: Given an extern alias declaration get the corresponding symbol for the alias that was introduced.
  syntax:
    content:
      CSharp: public static IAliasSymbol GetDeclaredSymbol(SemanticModel semanticModel, ExternAliasDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: ExternAliasDirectiveSyntax
        name: ExternAliasDirectiveSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: IAliasSymbol
      type:
        id: Microsoft.CodeAnalysis.IAliasSymbol
        name: IAliasSymbol
        href: Microsoft.CodeAnalysis.IAliasSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,ExternAliasDirectiveSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, ParameterSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1420
  summary: Given a parameter declaration syntax node, get the corresponding symbol.
  syntax:
    content:
      CSharp: public static IParameterSymbol GetDeclaredSymbol(SemanticModel semanticModel, ParameterSyntax declarationSyntax, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
        name: ParameterSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax.yml
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: IParameterSymbol
      type:
        id: Microsoft.CodeAnalysis.IParameterSymbol
        name: IParameterSymbol
        href: Microsoft.CodeAnalysis.IParameterSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,TypeParameterSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, TypeParameterSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, TypeParameterSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1436
  summary: Given a type parameter declaration (field or method), get the corresponding symbol
  syntax:
    content:
      CSharp: public static ITypeParameterSymbol GetDeclaredSymbol(SemanticModel semanticModel, TypeParameterSyntax typeParameter, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: typeParameter
      type:
        id: TypeParameterSyntax
        name: TypeParameterSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: ITypeParameterSymbol
      type:
        id: Microsoft.CodeAnalysis.ITypeParameterSymbol
        name: ITypeParameterSymbol
        href: Microsoft.CodeAnalysis.ITypeParameterSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,TypeParameterSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,ForEachStatementSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, ForEachStatementSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, ForEachStatementSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1452
  summary: Given a foreach statement, get the symbol for the iteration variable
  syntax:
    content:
      CSharp: public static ILocalSymbol GetDeclaredSymbol(SemanticModel semanticModel, ForEachStatementSyntax forEachStatement, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: forEachStatement
      type:
        id: ForEachStatementSyntax
        name: ForEachStatementSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: ILocalSymbol
      type:
        id: Microsoft.CodeAnalysis.ILocalSymbol
        name: ILocalSymbol
        href: Microsoft.CodeAnalysis.ILocalSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,ForEachStatementSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,CatchDeclarationSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, CatchDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, CatchDeclarationSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1468
  summary: Given a catch declaration, get the symbol for the exception variable
  syntax:
    content:
      CSharp: public static ILocalSymbol GetDeclaredSymbol(SemanticModel semanticModel, CatchDeclarationSyntax catchDeclaration, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: catchDeclaration
      type:
        id: CatchDeclarationSyntax
        name: CatchDeclarationSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: ILocalSymbol
      type:
        id: Microsoft.CodeAnalysis.ILocalSymbol
        name: ILocalSymbol
        href: Microsoft.CodeAnalysis.ILocalSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,CatchDeclarationSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,QueryClauseSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, QueryClauseSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, QueryClauseSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1481
  syntax:
    content:
      CSharp: public static IRangeVariableSymbol GetDeclaredSymbol(SemanticModel semanticModel, QueryClauseSyntax queryClause, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: queryClause
      type:
        id: QueryClauseSyntax
        name: QueryClauseSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: IRangeVariableSymbol
      type:
        id: Microsoft.CodeAnalysis.IRangeVariableSymbol
        name: IRangeVariableSymbol
        href: Microsoft.CodeAnalysis.IRangeVariableSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,QueryClauseSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,JoinIntoClauseSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, JoinIntoClauseSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, JoinIntoClauseSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1497
  summary: Get the query range variable declared in a join into clause.
  syntax:
    content:
      CSharp: public static IRangeVariableSymbol GetDeclaredSymbol(SemanticModel semanticModel, JoinIntoClauseSyntax node, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: node
      type:
        id: JoinIntoClauseSyntax
        name: JoinIntoClauseSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: IRangeVariableSymbol
      type:
        id: Microsoft.CodeAnalysis.IRangeVariableSymbol
        name: IRangeVariableSymbol
        href: Microsoft.CodeAnalysis.IRangeVariableSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,JoinIntoClauseSyntax,CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,QueryContinuationSyntax,CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, QueryContinuationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, QueryContinuationSyntax, CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1513
  summary: Get the query range variable declared in a query continuation clause.
  syntax:
    content:
      CSharp: public static IRangeVariableSymbol GetDeclaredSymbol(SemanticModel semanticModel, QueryContinuationSyntax node, CancellationToken cancellationToken = null)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: node
      type:
        id: QueryContinuationSyntax
        name: QueryContinuationSyntax
        isExternal: true
    - id: cancellationToken
      type:
        id: CancellationToken
        name: CancellationToken
        isExternal: true
    return:
      id: IRangeVariableSymbol
      type:
        id: Microsoft.CodeAnalysis.IRangeVariableSymbol
        name: IRangeVariableSymbol
        href: Microsoft.CodeAnalysis.IRangeVariableSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,QueryContinuationSyntax,CancellationToken)
