items:
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: CSharpExtensions
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions
  type: Class
  source:
    remote: &o0
      branch: master
      repo: https://github.com/chenkennt/roslyn.git
      description: ef085ea0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 134
  syntax:
    content:
      CSharp: public static class CSharpExtensions
  inheritance:
  - id: System.Object
    name: System.Object
    isExternal: true
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions
  children:
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimStringLiteral(Microsoft.CodeAnalysis.SyntaxToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimIdentifier(Microsoft.CodeAnalysis.SyntaxToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.VarianceKindFromToken(Microsoft.CodeAnalysis.SyntaxToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetIndexerGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConstantValue(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetQueryClauseInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax,System.Threading.CancellationToken)
  - Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: Kind(SyntaxToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 145
  syntax:
    content:
      CSharp: public static SyntaxKind Kind(this SyntaxToken token)
    parameters:
    - id: token
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
    return:
      id: SyntaxKind
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: Kind(SyntaxTrivia)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 151
  syntax:
    content:
      CSharp: public static SyntaxKind Kind(this SyntaxTrivia trivia)
    parameters:
    - id: trivia
      type:
        id: Microsoft.CodeAnalysis.SyntaxTrivia
        name: SyntaxTrivia
        href: Microsoft.CodeAnalysis.SyntaxTrivia
    return:
      id: SyntaxKind
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxTrivia)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: Kind(SyntaxNode)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 157
  syntax:
    content:
      CSharp: public static SyntaxKind Kind(this SyntaxNode node)
    parameters:
    - id: node
      type:
        id: Microsoft.CodeAnalysis.SyntaxNode
        name: SyntaxNode
        href: Microsoft.CodeAnalysis.SyntaxNode
    return:
      id: SyntaxKind
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNode)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: Kind(SyntaxNodeOrToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 163
  syntax:
    content:
      CSharp: public static SyntaxKind Kind(this SyntaxNodeOrToken nodeOrToken)
    parameters:
    - id: nodeOrToken
      type:
        id: Microsoft.CodeAnalysis.SyntaxNodeOrToken
        name: SyntaxNodeOrToken
        href: Microsoft.CodeAnalysis.SyntaxNodeOrToken
    return:
      id: SyntaxKind
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind(Microsoft.CodeAnalysis.SyntaxNodeOrToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: IsKeyword(SyntaxToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 169
  syntax:
    content:
      CSharp: public static bool IsKeyword(this SyntaxToken token)
    parameters:
    - id: token
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
    return:
      id: Boolean
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsKeyword(Microsoft.CodeAnalysis.SyntaxToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: IsContextualKeyword(SyntaxToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 174
  syntax:
    content:
      CSharp: public static bool IsContextualKeyword(this SyntaxToken token)
    parameters:
    - id: token
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
    return:
      id: Boolean
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: IsReservedKeyword(SyntaxToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 179
  syntax:
    content:
      CSharp: public static bool IsReservedKeyword(this SyntaxToken token)
    parameters:
    - id: token
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
    return:
      id: Boolean
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimStringLiteral(Microsoft.CodeAnalysis.SyntaxToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: IsVerbatimStringLiteral(SyntaxToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimStringLiteral(Microsoft.CodeAnalysis.SyntaxToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 184
  syntax:
    content:
      CSharp: public static bool IsVerbatimStringLiteral(this SyntaxToken token)
    parameters:
    - id: token
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
    return:
      id: Boolean
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimStringLiteral(Microsoft.CodeAnalysis.SyntaxToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimIdentifier(Microsoft.CodeAnalysis.SyntaxToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: IsVerbatimIdentifier(SyntaxToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimIdentifier(Microsoft.CodeAnalysis.SyntaxToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 189
  syntax:
    content:
      CSharp: public static bool IsVerbatimIdentifier(this SyntaxToken token)
    parameters:
    - id: token
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
    return:
      id: Boolean
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.IsVerbatimIdentifier(Microsoft.CodeAnalysis.SyntaxToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.VarianceKindFromToken(Microsoft.CodeAnalysis.SyntaxToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: VarianceKindFromToken(SyntaxToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.VarianceKindFromToken(Microsoft.CodeAnalysis.SyntaxToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 194
  syntax:
    content:
      CSharp: public static VarianceKind VarianceKindFromToken(this SyntaxToken node)
    parameters:
    - id: node
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
    return:
      id: VarianceKind
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.VarianceKindFromToken(Microsoft.CodeAnalysis.SyntaxToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: Insert(SyntaxTokenList, int, params SyntaxToken[])
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList, int, params Microsoft.CodeAnalysis.SyntaxToken[])
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 208
  summary: Insert one or more tokens in the list at the specified index.
  syntax:
    content:
      CSharp: public static SyntaxTokenList Insert(this SyntaxTokenList list, int index, params SyntaxToken[] items)
    parameters:
    - id: list
      type:
        id: Microsoft.CodeAnalysis.SyntaxTokenList
        name: SyntaxTokenList
        href: Microsoft.CodeAnalysis.SyntaxTokenList
    - id: index
      type:
        id: System.Int32
        name: System.Int32
        isExternal: true
    - id: items
      type:
        id: System.Array
        name: System.Array
        isExternal: true
    return:
      id: SyntaxTokenList
      description: A new list with the tokens inserted.
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: ReplaceTrivia(SyntaxToken, IEnumerable<SyntaxTrivia>, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia>)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia>, System.Func<Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia>)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 251
  summary: Creates a new token with the specified old trivia replaced with computed new trivia.
  syntax:
    content:
      CSharp: public static SyntaxToken ReplaceTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia)
    parameters:
    - id: token
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
    - id: trivia
      type:
        id: System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia}
        name: System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia}
        isExternal: true
      description: The trivia to be replaced; descendants of the root token.
    - id: computeReplacementTrivia
      type:
        id: System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia}
        name: System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia}
        isExternal: true
      description: >-
        A function that computes a replacement trivia for

        the argument trivia. The first argument is the original trivia. The second argument is

        the same trivia rewritten with replaced structure.
    return:
      id: SyntaxToken
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: ReplaceTrivia(SyntaxToken, SyntaxTrivia, SyntaxTrivia)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 264
  summary: >-
    Creates a new token with the specified old trivia replaced with a new trivia. The old trivia may appear in

    the token's leading or trailing trivia.
  syntax:
    content:
      CSharp: public static SyntaxToken ReplaceTrivia(this SyntaxToken token, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia)
    parameters:
    - id: token
      type:
        id: Microsoft.CodeAnalysis.SyntaxToken
        name: SyntaxToken
        href: Microsoft.CodeAnalysis.SyntaxToken
    - id: oldTrivia
      type:
        id: Microsoft.CodeAnalysis.SyntaxTrivia
        name: SyntaxTrivia
        href: Microsoft.CodeAnalysis.SyntaxTrivia
      description: The trivia to be replaced.
    - id: newTrivia
      type:
        id: Microsoft.CodeAnalysis.SyntaxTrivia
        name: SyntaxTrivia
        href: Microsoft.CodeAnalysis.SyntaxTrivia
      description: >-
        The new trivia to use in the new tree in place of the old

        trivia.
    return:
      id: SyntaxToken
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetFirstDirective(SyntaxNode, Func<DirectiveTriviaSyntax, bool>)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode, System.Func<Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool>)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 327
  summary: Gets the first directive of the tree rooted by this node.
  syntax:
    content:
      CSharp: public static DirectiveTriviaSyntax GetFirstDirective(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null)
    parameters:
    - id: node
      type:
        id: Microsoft.CodeAnalysis.SyntaxNode
        name: SyntaxNode
        href: Microsoft.CodeAnalysis.SyntaxNode
    - id: predicate
      type:
        id: System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean}
        name: System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean}
        isExternal: true
    return:
      id: DirectiveTriviaSyntax
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetLastDirective(SyntaxNode, Func<DirectiveTriviaSyntax, bool>)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode, System.Func<Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool>)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 335
  summary: Gets the last directive of the tree rooted by this node.
  syntax:
    content:
      CSharp: public static DirectiveTriviaSyntax GetLastDirective(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null)
    parameters:
    - id: node
      type:
        id: Microsoft.CodeAnalysis.SyntaxNode
        name: SyntaxNode
        href: Microsoft.CodeAnalysis.SyntaxNode
    - id: predicate
      type:
        id: System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean}
        name: System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean}
        isExternal: true
    return:
      id: DirectiveTriviaSyntax
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetCompilationUnitRoot(SyntaxTree, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 342
  syntax:
    content:
      CSharp: public static CompilationUnitSyntax GetCompilationUnitRoot(this SyntaxTree tree, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: tree
      type:
        id: Microsoft.CodeAnalysis.SyntaxTree
        name: SyntaxTree
        href: Microsoft.CodeAnalysis.SyntaxTree
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: CompilationUnitSyntax
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCompilationUnitRoot(Microsoft.CodeAnalysis.SyntaxTree,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: ClassifyConversion(Compilation, ITypeSymbol, ITypeSymbol)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation, Microsoft.CodeAnalysis.ITypeSymbol, Microsoft.CodeAnalysis.ITypeSymbol)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 379
  syntax:
    content:
      CSharp: public static Conversion ClassifyConversion(this Compilation compilation, ITypeSymbol source, ITypeSymbol destination)
    parameters:
    - id: compilation
      type:
        id: Microsoft.CodeAnalysis.Compilation
        name: Compilation
        href: Microsoft.CodeAnalysis.Compilation
    - id: source
      type:
        id: Microsoft.CodeAnalysis.ITypeSymbol
        name: ITypeSymbol
        href: Microsoft.CodeAnalysis.ITypeSymbol
    - id: destination
      type:
        id: Microsoft.CodeAnalysis.ITypeSymbol
        name: ITypeSymbol
        href: Microsoft.CodeAnalysis.ITypeSymbol
    return:
      id: Conversion
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSymbolInfo(SemanticModel, OrderingSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 397
  summary: Gets the semantic information for an ordering clause in an orderby query clause.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, OrderingSyntax node, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: node
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax
        name: OrderingSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSymbolInfo(SemanticModel, SelectOrGroupClauseSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 413
  summary: Gets the semantic information associated with a select or group clause.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: node
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax
        name: SelectOrGroupClauseSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSymbolInfo(SemanticModel, ExpressionSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 437
  summary: >-
    Returns what symbol(s), if any, the given expression syntax bound to in the program.



    An AliasSymbol will never be returned by this method. What the alias refers to will be

    returned instead. To get information about aliases, call GetAliasInfo.



    If binding the type name C in the expression "new C(...)" the actual constructor bound to

    will be returned (or all constructor if overload resolution failed). This occurs as long as C

    unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple

    types, or C binds to a static class, then type(s) are returned.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: expression
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
        name: ExpressionSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetCollectionInitializerSymbolInfo(SemanticModel, ExpressionSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 454
  summary: >-
    Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax

    within [Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax.Initializer](Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax.yml).
  syntax:
    content:
      CSharp: public static SymbolInfo GetCollectionInitializerSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: expression
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
        name: ExpressionSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSymbolInfo(SemanticModel, ConstructorInitializerSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 470
  summary: Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: constructorInitializer
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
        name: ConstructorInitializerSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSymbolInfo(SemanticModel, AttributeSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 486
  summary: Returns what symbol(s), if any, the given attribute syntax bound to in the program.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: attributeSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
        name: AttributeSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSymbolInfo(SemanticModel, CrefSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 502
  summary: Gets the semantic information associated with a documentation comment cref.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, CrefSyntax crefSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: crefSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax
        name: CrefSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSpeculativeSymbolInfo(SemanticModel, int, ExpressionSyntax, SpeculativeBindingOption)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 520
  summary: >-
    Binds the expression in the context of the specified location and gets symbol information.

    This method is used to get symbol information about an expression that did not actually

    appear in the source code.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: System.Int32
        isExternal: true
    - id: expression
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
        name: ExpressionSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax.yml
    - id: bindingOption
      type:
        id: Microsoft.CodeAnalysis.SpeculativeBindingOption
        name: SpeculativeBindingOption
        href: Microsoft.CodeAnalysis.SpeculativeBindingOption
    return:
      id: SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSpeculativeSymbolInfo(SemanticModel, int, CrefSyntax, SpeculativeBindingOption)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 538
  summary: >-
    Binds the CrefSyntax expression in the context of the specified location and gets symbol information.

    This method is used to get symbol information about an expression that did not actually

    appear in the source code.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, CrefSyntax expression, SpeculativeBindingOption bindingOption)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: System.Int32
        isExternal: true
    - id: expression
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax
        name: CrefSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax.yml
    - id: bindingOption
      type:
        id: Microsoft.CodeAnalysis.SpeculativeBindingOption
        name: SpeculativeBindingOption
        href: Microsoft.CodeAnalysis.SpeculativeBindingOption
    return:
      id: SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSpeculativeSymbolInfo(SemanticModel, int, AttributeSyntax)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 556
  summary: >-
    Bind the attribute in the context of the specified location and get semantic information

    such as type, symbols and diagnostics. This method is used to get semantic information about an attribute

    that did not actually appear in the source code.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, AttributeSyntax attribute)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: System.Int32
        isExternal: true
    - id: attribute
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
        name: AttributeSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax.yml
    return:
      id: SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSpeculativeSymbolInfo(SemanticModel, int, ConstructorInitializerSyntax)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 576
  summary: >-
    Bind the constructor initializer in the context of the specified location and get semantic information

    such as type, symbols and diagnostics. This method is used to get semantic information about a constructor

    initializer that did not actually appear in the source code.



    NOTE: This will only work in locations where there is already a constructor initializer.
  syntax:
    content:
      CSharp: public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: System.Int32
        isExternal: true
    - id: constructorInitializer
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
        name: ConstructorInitializerSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax.yml
    return:
      id: SymbolInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetTypeInfo(SemanticModel, ConstructorInitializerSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 592
  summary: Gets type information about a constructor initializer.
  syntax:
    content:
      CSharp: public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: constructorInitializer
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
        name: ConstructorInitializerSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: TypeInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetTypeInfo(SemanticModel, SelectOrGroupClauseSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 606
  syntax:
    content:
      CSharp: public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: node
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax
        name: SelectOrGroupClauseSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: TypeInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetTypeInfo(SemanticModel, ExpressionSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 622
  summary: Gets type information about an expression.
  syntax:
    content:
      CSharp: public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: expression
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
        name: ExpressionSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: TypeInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetTypeInfo(SemanticModel, AttributeSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 638
  summary: Gets type information about an attribute.
  syntax:
    content:
      CSharp: public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: attributeSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
        name: AttributeSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: TypeInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSpeculativeTypeInfo(SemanticModel, int, ExpressionSyntax, SpeculativeBindingOption)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 656
  summary: >-
    Binds the expression in the context of the specified location and gets type information.

    This method is used to get type information about an expression that did not actually

    appear in the source code.
  syntax:
    content:
      CSharp: public static TypeInfo GetSpeculativeTypeInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: System.Int32
        isExternal: true
    - id: expression
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
        name: ExpressionSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax.yml
    - id: bindingOption
      type:
        id: Microsoft.CodeAnalysis.SpeculativeBindingOption
        name: SpeculativeBindingOption
        href: Microsoft.CodeAnalysis.SpeculativeBindingOption
    return:
      id: TypeInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetConversion(SemanticModel, SyntaxNode, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 669
  syntax:
    content:
      CSharp: public static Conversion GetConversion(this SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: expression
      type:
        id: Microsoft.CodeAnalysis.SyntaxNode
        name: SyntaxNode
        href: Microsoft.CodeAnalysis.SyntaxNode
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: Conversion
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSpeculativeConversion(SemanticModel, int, ExpressionSyntax, SpeculativeBindingOption)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeConversion(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 682
  syntax:
    content:
      CSharp: public static Conversion GetSpeculativeConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: System.Int32
        isExternal: true
    - id: expression
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
        name: ExpressionSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax.yml
    - id: bindingOption
      type:
        id: Microsoft.CodeAnalysis.SpeculativeBindingOption
        name: SpeculativeBindingOption
        href: Microsoft.CodeAnalysis.SpeculativeBindingOption
    return:
      id: Conversion
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetForEachStatementInfo(SemanticModel, ForEachStatementSyntax)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 695
  syntax:
    content:
      CSharp: public static ForEachStatementInfo GetForEachStatementInfo(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: forEachStatement
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
        name: ForEachStatementSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax.yml
    return:
      id: ForEachStatementInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetAwaitExpressionInfo(SemanticModel, AwaitExpressionSyntax)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 708
  syntax:
    content:
      CSharp: public static AwaitExpressionInfo GetAwaitExpressionInfo(this SemanticModel semanticModel, AwaitExpressionSyntax awaitExpression)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: awaitExpression
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax
        name: AwaitExpressionSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax.yml
    return:
      id: AwaitExpressionInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetMemberGroup(SemanticModel, ExpressionSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 721
  syntax:
    content:
      CSharp: public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: expression
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
        name: ExpressionSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: ImmutableArray
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetMemberGroup(SemanticModel, AttributeSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 734
  syntax:
    content:
      CSharp: public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: attribute
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
        name: AttributeSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: ImmutableArray
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetMemberGroup(SemanticModel, ConstructorInitializerSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 747
  syntax:
    content:
      CSharp: public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, ConstructorInitializerSyntax initializer, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: initializer
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
        name: ConstructorInitializerSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: ImmutableArray
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetIndexerGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetIndexerGroup(SemanticModel, ExpressionSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetIndexerGroup(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 763
  summary: Returns the list of accessible, non-hidden indexers that could be invoked with the given expression as receiver.
  syntax:
    content:
      CSharp: public static ImmutableArray<IPropertySymbol> GetIndexerGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: expression
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
        name: ExpressionSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: ImmutableArray
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetIndexerGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConstantValue(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetConstantValue(SemanticModel, ExpressionSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConstantValue(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 776
  syntax:
    content:
      CSharp: public static Optional<object> GetConstantValue(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: expression
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
        name: ExpressionSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: Optional
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConstantValue(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetQueryClauseInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetQueryClauseInfo(SemanticModel, QueryClauseSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetQueryClauseInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 792
  summary: Gets the semantic information associated with a query clause.
  syntax:
    content:
      CSharp: public static QueryClauseInfo GetQueryClauseInfo(this SemanticModel semanticModel, QueryClauseSyntax node, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: node
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax
        name: QueryClauseSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: QueryClauseInfo
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetQueryClauseInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetAliasInfo(SemanticModel, IdentifierNameSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 809
  summary: >-
    If  resolves to an alias name, return the AliasSymbol corresponding

    to A. Otherwise return null.
  syntax:
    content:
      CSharp: public static IAliasSymbol GetAliasInfo(this SemanticModel semanticModel, IdentifierNameSyntax nameSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: nameSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
        name: IdentifierNameSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: IAliasSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetSpeculativeAliasInfo(SemanticModel, int, IdentifierNameSyntax, SpeculativeBindingOption)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 826
  summary: >-
    Binds the name in the context of the specified location and sees if it resolves to an

    alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
  syntax:
    content:
      CSharp: public static IAliasSymbol GetSpeculativeAliasInfo(this SemanticModel semanticModel, int position, IdentifierNameSyntax nameSyntax, SpeculativeBindingOption bindingOption)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: System.Int32
        isExternal: true
    - id: nameSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax
        name: IdentifierNameSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax.yml
    - id: bindingOption
      type:
        id: Microsoft.CodeAnalysis.SpeculativeBindingOption
        name: SpeculativeBindingOption
        href: Microsoft.CodeAnalysis.SpeculativeBindingOption
    return:
      id: IAliasSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: AnalyzeControlFlow(SemanticModel, StatementSyntax, StatementSyntax)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 842
  summary: Analyze control-flow within a part of a method body.
  syntax:
    content:
      CSharp: public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: firstStatement
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
        name: StatementSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax.yml
    - id: lastStatement
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
        name: StatementSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax.yml
    return:
      id: ControlFlowAnalysis
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: AnalyzeControlFlow(SemanticModel, StatementSyntax)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 858
  summary: Analyze control-flow within a part of a method body.
  syntax:
    content:
      CSharp: public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax statement)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: statement
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
        name: StatementSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax.yml
    return:
      id: ControlFlowAnalysis
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: AnalyzeDataFlow(SemanticModel, ExpressionSyntax)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 874
  summary: Analyze data-flow within an expression.
  syntax:
    content:
      CSharp: public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, ExpressionSyntax expression)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: expression
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
        name: ExpressionSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax.yml
    return:
      id: DataFlowAnalysis
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: AnalyzeDataFlow(SemanticModel, StatementSyntax, StatementSyntax)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 890
  summary: Analyze data-flow within a part of a method body.
  syntax:
    content:
      CSharp: public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: firstStatement
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
        name: StatementSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax.yml
    - id: lastStatement
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
        name: StatementSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax.yml
    return:
      id: DataFlowAnalysis
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: AnalyzeDataFlow(SemanticModel, StatementSyntax)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 906
  summary: Analyze data-flow within a part of a method body.
  syntax:
    content:
      CSharp: public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax statement)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: statement
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
        name: StatementSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax.yml
    return:
      id: DataFlowAnalysis
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: TryGetSpeculativeSemanticModelForMethodBody(SemanticModel, int, BaseMethodDeclarationSyntax, out SemanticModel)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax, out Microsoft.CodeAnalysis.SemanticModel)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 924
  summary: >-
    Get a SemanticModel object that is associated with a method body that did not appear in this source code.

    Given  must lie within an existing method body of the Root syntax node for this SemanticModel.

    Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
  syntax:
    content:
      CSharp: public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, BaseMethodDeclarationSyntax method, out SemanticModel speculativeModel)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: System.Int32
        isExternal: true
    - id: method
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax
        name: BaseMethodDeclarationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax.yml
    - id: speculativeModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    return:
      id: Boolean
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: TryGetSpeculativeSemanticModelForMethodBody(SemanticModel, int, AccessorDeclarationSyntax, out SemanticModel)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax, out Microsoft.CodeAnalysis.SemanticModel)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 943
  summary: >-
    Get a SemanticModel object that is associated with a method body that did not appear in this source code.

    Given  must lie within an existing method body of the Root syntax node for this SemanticModel.

    Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
  syntax:
    content:
      CSharp: public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, AccessorDeclarationSyntax accessor, out SemanticModel speculativeModel)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: System.Int32
        isExternal: true
    - id: accessor
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
        name: AccessorDeclarationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax.yml
    - id: speculativeModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    return:
      id: Boolean
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: TryGetSpeculativeSemanticModel(SemanticModel, int, TypeSyntax, out SemanticModel, SpeculativeBindingOption)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax, out Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.SpeculativeBindingOption)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 962
  summary: >-
    Get a SemanticModel object that is associated with a type syntax node that did not appear in

    this source code. This can be used to get detailed semantic information about sub-parts

    of a type syntax that did not appear in source code.
  syntax:
    content:
      CSharp: public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, TypeSyntax type, out SemanticModel speculativeModel, SpeculativeBindingOption bindingOption = SpeculativeBindingOption.BindAsExpression)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: System.Int32
        isExternal: true
    - id: type
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
        name: TypeSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax.yml
    - id: speculativeModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: bindingOption
      type:
        id: Microsoft.CodeAnalysis.SpeculativeBindingOption
        name: SpeculativeBindingOption
        href: Microsoft.CodeAnalysis.SpeculativeBindingOption
    return:
      id: Boolean
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: TryGetSpeculativeSemanticModel(SemanticModel, int, CrefSyntax, out SemanticModel)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax, out Microsoft.CodeAnalysis.SemanticModel)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 981
  summary: >-
    Get a SemanticModel object that is associated with a cref syntax node that did not appear in

    this source code. This can be used to get detailed semantic information about sub-parts

    of a cref syntax that did not appear in source code.
  syntax:
    content:
      CSharp: public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, CrefSyntax crefSyntax, out SemanticModel speculativeModel)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: System.Int32
        isExternal: true
    - id: crefSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax
        name: CrefSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax.yml
    - id: speculativeModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    return:
      id: Boolean
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SemanticModel@)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: TryGetSpeculativeSemanticModel(SemanticModel, int, StatementSyntax, out SemanticModel)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, out Microsoft.CodeAnalysis.SemanticModel)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1000
  summary: >-
    Get a SemanticModel object that is associated with a statement that did not appear in

    this source code. This can be used to get detailed semantic information about sub-parts

    of a statement that did not appear in source code.
  syntax:
    content:
      CSharp: public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, StatementSyntax statement, out SemanticModel speculativeModel)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: System.Int32
        isExternal: true
    - id: statement
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
        name: StatementSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax.yml
    - id: speculativeModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    return:
      id: Boolean
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: TryGetSpeculativeSemanticModel(SemanticModel, int, EqualsValueClauseSyntax, out SemanticModel)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax, out Microsoft.CodeAnalysis.SemanticModel)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1019
  summary: >-
    Get a SemanticModel object that is associated with an initializer that did not appear in

    this source code. This can be used to get detailed semantic information about sub-parts

    of a field initializer or default parameter value that did not appear in source code.
  syntax:
    content:
      CSharp: public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, EqualsValueClauseSyntax initializer, out SemanticModel speculativeModel)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: System.Int32
        isExternal: true
    - id: initializer
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
        name: EqualsValueClauseSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax.yml
    - id: speculativeModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    return:
      id: Boolean
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: TryGetSpeculativeSemanticModel(SemanticModel, int, ArrowExpressionClauseSyntax, out SemanticModel)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax, out Microsoft.CodeAnalysis.SemanticModel)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1038
  summary: >-
    Get a SemanticModel object that is associated with an expression body that did not appear in

    this source code. This can be used to get detailed semantic information about sub-parts

    of an expression body that did not appear in source code.
  syntax:
    content:
      CSharp: public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ArrowExpressionClauseSyntax expressionBody, out SemanticModel speculativeModel)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: System.Int32
        isExternal: true
    - id: expressionBody
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax
        name: ArrowExpressionClauseSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax.yml
    - id: speculativeModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    return:
      id: Boolean
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: TryGetSpeculativeSemanticModel(SemanticModel, int, ConstructorInitializerSyntax, out SemanticModel)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax, out Microsoft.CodeAnalysis.SemanticModel)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1059
  summary: >-
    Get a SemanticModel object that is associated with a constructor initializer that did not appear in

    this source code. This can be used to get detailed semantic information about sub-parts

    of a constructor initializer that did not appear in source code.



    NOTE: This will only work in locations where there is already a constructor initializer.
  syntax:
    content:
      CSharp: public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer, out SemanticModel speculativeModel)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: System.Int32
        isExternal: true
    - id: constructorInitializer
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax
        name: ConstructorInitializerSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax.yml
    - id: speculativeModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    return:
      id: Boolean
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.SemanticModel@)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: TryGetSpeculativeSemanticModel(SemanticModel, int, AttributeSyntax, out SemanticModel)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax, out Microsoft.CodeAnalysis.SemanticModel)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1078
  summary: >-
    Get a SemanticModel object that is associated with an attribute that did not appear in

    this source code. This can be used to get detailed semantic information about sub-parts

    of an attribute that did not appear in source code.
  syntax:
    content:
      CSharp: public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, AttributeSyntax attribute, out SemanticModel speculativeModel)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: System.Int32
        isExternal: true
    - id: attribute
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax
        name: AttributeSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax.yml
    - id: speculativeModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    return:
      id: Boolean
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: ClassifyConversion(SemanticModel, ExpressionSyntax, ITypeSymbol, bool)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.ITypeSymbol, bool)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1097
  summary: >-
    Determines what type of conversion, if any, would be used if a given expression was

    converted to a given type.  If isExplicitInSource is true, the conversion produced is

    that which would be used if the conversion were done for a cast expression.
  syntax:
    content:
      CSharp: public static Conversion ClassifyConversion(this SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: expression
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
        name: ExpressionSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax.yml
    - id: destination
      type:
        id: Microsoft.CodeAnalysis.ITypeSymbol
        name: ITypeSymbol
        href: Microsoft.CodeAnalysis.ITypeSymbol
    - id: isExplicitInSource
      type:
        id: System.Boolean
        name: System.Boolean
        isExternal: true
    return:
      id: Conversion
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: ClassifyConversion(SemanticModel, int, ExpressionSyntax, ITypeSymbol, bool)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel, int, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.ITypeSymbol, bool)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1115
  summary: >-
    Determines what type of conversion, if any, would be used if a given expression was

    converted to a given type.  If isExplicitInSource is true, the conversion produced is

    that which would be used if the conversion were done for a cast expression.
  syntax:
    content:
      CSharp: public static Conversion ClassifyConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false)
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: position
      type:
        id: System.Int32
        name: System.Int32
        isExternal: true
    - id: expression
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
        name: ExpressionSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax.yml
    - id: destination
      type:
        id: Microsoft.CodeAnalysis.ITypeSymbol
        name: ITypeSymbol
        href: Microsoft.CodeAnalysis.ITypeSymbol
    - id: isExplicitInSource
      type:
        id: System.Boolean
        name: System.Boolean
        isExternal: true
    return:
      id: Conversion
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, MemberDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1131
  summary: Given a member declaration syntax, get the corresponding symbol.
  syntax:
    content:
      CSharp: public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, MemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
        name: MemberDeclarationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: ISymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, NamespaceDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1148
  summary: >-
    Given a namespace declaration syntax node, get the corresponding namespace symbol for

    the declaration assembly.
  syntax:
    content:
      CSharp: public static INamespaceSymbol GetDeclaredSymbol(this SemanticModel semanticModel, NamespaceDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax
        name: NamespaceDeclarationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: INamespaceSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, BaseTypeDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1164
  summary: Given a type declaration, get the corresponding type symbol.
  syntax:
    content:
      CSharp: public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseTypeDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax
        name: BaseTypeDeclarationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: INamedTypeSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, DelegateDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1180
  summary: Given a delegate declaration, get the corresponding type symbol.
  syntax:
    content:
      CSharp: public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, DelegateDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax
        name: DelegateDeclarationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: INamedTypeSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, EnumMemberDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1196
  summary: Given a enum member declaration, get the corresponding field symbol.
  syntax:
    content:
      CSharp: public static IFieldSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax
        name: EnumMemberDeclarationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: IFieldSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, BaseMethodDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1212
  summary: Given a base method declaration syntax, get the corresponding method symbol.
  syntax:
    content:
      CSharp: public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseMethodDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax
        name: BaseMethodDeclarationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: IMethodSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, BasePropertyDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1228
  summary: Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.
  syntax:
    content:
      CSharp: public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, BasePropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax
        name: BasePropertyDeclarationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: ISymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, PropertyDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1244
  summary: Given a syntax node that declares a property, get the corresponding declared symbol.
  syntax:
    content:
      CSharp: public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, PropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax
        name: PropertyDeclarationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: IPropertySymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, IndexerDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1260
  summary: Given a syntax node that declares an indexer, get the corresponding declared symbol.
  syntax:
    content:
      CSharp: public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, IndexerDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax
        name: IndexerDeclarationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: IPropertySymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, EventDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1276
  summary: Given a syntax node that declares a (custom) event, get the corresponding event symbol.
  syntax:
    content:
      CSharp: public static IEventSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EventDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax
        name: EventDeclarationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: IEventSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, AnonymousObjectMemberDeclaratorSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1292
  summary: Given a syntax node of anonymous object creation initializer, get the anonymous object property symbol.
  syntax:
    content:
      CSharp: public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declaratorSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax
        name: AnonymousObjectMemberDeclaratorSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: IPropertySymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, AnonymousObjectCreationExpressionSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1308
  summary: Given a syntax node of anonymous object creation expression, get the anonymous object type symbol.
  syntax:
    content:
      CSharp: public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectCreationExpressionSyntax declaratorSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declaratorSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax
        name: AnonymousObjectCreationExpressionSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: INamedTypeSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, AccessorDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1324
  summary: Given a syntax node that declares a property or member accessor, get the corresponding symbol.
  syntax:
    content:
      CSharp: public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AccessorDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax
        name: AccessorDeclarationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: IMethodSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, VariableDeclaratorSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1340
  summary: Given a variable declarator syntax, get the corresponding symbol.
  syntax:
    content:
      CSharp: public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, VariableDeclaratorSyntax declarationSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax
        name: VariableDeclaratorSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: ISymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, LabeledStatementSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1356
  summary: Given a labeled statement syntax, get the corresponding label symbol.
  syntax:
    content:
      CSharp: public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, LabeledStatementSyntax declarationSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax
        name: LabeledStatementSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: ILabelSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, SwitchLabelSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1372
  summary: Given a switch label syntax, get the corresponding label symbol.
  syntax:
    content:
      CSharp: public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, SwitchLabelSyntax declarationSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax
        name: SwitchLabelSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: ILabelSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, UsingDirectiveSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1388
  summary: Given a using declaration get the corresponding symbol for the using alias that was introduced.
  syntax:
    content:
      CSharp: public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, UsingDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax
        name: UsingDirectiveSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: IAliasSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, ExternAliasDirectiveSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1404
  summary: Given an extern alias declaration get the corresponding symbol for the alias that was introduced.
  syntax:
    content:
      CSharp: public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ExternAliasDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax
        name: ExternAliasDirectiveSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: IAliasSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, ParameterSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1420
  summary: Given a parameter declaration syntax node, get the corresponding symbol.
  syntax:
    content:
      CSharp: public static IParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ParameterSyntax declarationSyntax, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: declarationSyntax
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax
        name: ParameterSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: IParameterSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, TypeParameterSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1436
  summary: Given a type parameter declaration (field or method), get the corresponding symbol
  syntax:
    content:
      CSharp: public static ITypeParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, TypeParameterSyntax typeParameter, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: typeParameter
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax
        name: TypeParameterSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: ITypeParameterSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, ForEachStatementSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1452
  summary: Given a foreach statement, get the symbol for the iteration variable
  syntax:
    content:
      CSharp: public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: forEachStatement
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax
        name: ForEachStatementSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: ILocalSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, CatchDeclarationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1468
  summary: Given a catch declaration, get the symbol for the exception variable
  syntax:
    content:
      CSharp: public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, CatchDeclarationSyntax catchDeclaration, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: catchDeclaration
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax
        name: CatchDeclarationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: ILocalSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, QueryClauseSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1481
  syntax:
    content:
      CSharp: public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryClauseSyntax queryClause, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: queryClause
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax
        name: QueryClauseSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: IRangeVariableSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, JoinIntoClauseSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1497
  summary: Get the query range variable declared in a join into clause.
  syntax:
    content:
      CSharp: public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, JoinIntoClauseSyntax node, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: node
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax
        name: JoinIntoClauseSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: IRangeVariableSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax,System.Threading.CancellationToken)
- uid: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax,System.Threading.CancellationToken)
  href: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.yml
  name: GetDeclaredSymbol(SemanticModel, QueryContinuationSyntax, CancellationToken)
  fullName: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax, System.Threading.CancellationToken)
  type: Method
  source:
    remote: *o0
    path: src/Compilers/CSharp/Portable/CSharpExtensions.cs
    startLine: 1513
  summary: Get the query range variable declared in a query continuation clause.
  syntax:
    content:
      CSharp: public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryContinuationSyntax node, CancellationToken cancellationToken = default (CancellationToken))
    parameters:
    - id: semanticModel
      type:
        id: Microsoft.CodeAnalysis.SemanticModel
        name: SemanticModel
        href: Microsoft.CodeAnalysis.SemanticModel
    - id: node
      type:
        id: Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax
        name: QueryContinuationSyntax
        href: Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax.yml
    - id: cancellationToken
      type:
        id: System.Threading.CancellationToken
        name: System.Threading.CancellationToken
        isExternal: true
    return:
      id: IRangeVariableSymbol
  id: Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax,System.Threading.CancellationToken)
